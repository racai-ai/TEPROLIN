import sys
import inspect
from pathlib import Path
import dynet as dy
import numpy as np

def orthonormal_VanillaLSTMBuilder(lstm_layers, input_dims, lstm_hiddens, pc):
    builder = dy.VanillaLSTMBuilder(lstm_layers, input_dims, lstm_hiddens, pc)

    for layer, params in enumerate(builder.get_parameters()):
        W = orthonormal_initializer(lstm_hiddens, lstm_hiddens + (lstm_hiddens if layer > 0 else input_dims))
        W_h, W_x = W[:, :lstm_hiddens], W[:, lstm_hiddens:]
        params[0].set_value(np.concatenate([W_x] * 4, 0))
        params[1].set_value(np.concatenate([W_h] * 4, 0))
        b = np.zeros(4 * lstm_hiddens, dtype=np.float32)
        b[lstm_hiddens:2 * lstm_hiddens] = -1.0
        params[2].set_value(b)

    return builder

def orthonormal_initializer(output_size, input_size):
    """Adopted from Timothy Dozat https://github.com/tdozat/Parser/blob/master/lib/linalg.py"""
    I = np.eye(output_size)
    lr = .1
    eps = .05 / (output_size + input_size)
    success = False
    tries = 0

    while not success and tries < 10:
        Q = np.random.randn(input_size, output_size) / np.sqrt(output_size)

        for i in range(100):
            QTQmI = Q.T.dot(Q) - I
            loss = np.sum(QTQmI ** 2 / 2)
            Q2 = Q ** 2
            Q -= \
                lr * Q.dot(QTQmI) / \
                (np.abs(Q2 + Q2.sum(axis = 0, keepdims = True) + Q2.sum(axis = 1, keepdims = True) - 1) + eps)

            if np.max(Q) > 1e6 or loss > 1e6 or not np.isfinite(loss):
                tries += 1
                lr /= 2
                break

        success = True

    if success:
        print("{0}.{1}[{2}]: orthogonal pretrainer loss is {3:.2e}".\
            format(
                Path(inspect.stack()[0].filename).stem,
                inspect.stack()[0].function,
                inspect.stack()[0].lineno,
                loss
            ), file = sys.stderr, flush = True)
    else:
        print("{0}.{1}[{2}]: orthogonal pretrainer failed, using non-orthogonal random matrix".\
            format(
                Path(inspect.stack()[0].filename).stem,
                inspect.stack()[0].function,
                inspect.stack()[0].lineno
            ), file = sys.stderr, flush = True)

        Q = np.random.randn(input_size, output_size) / np.sqrt(output_size)

    return np.transpose(Q.astype(np.float32))
